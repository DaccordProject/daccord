name: Release

on:
  push:
    tags:
      - "v*"

env:
  GODOT_VERSION: "4.5.0"
  GODOTLITE_TAG: "v4.5"
  GUT_VERSION: "9.5.0"
  SENTRY_VERSION: "1.3.2"

permissions:
  contents: write

jobs:
  ci:
    name: CI
    uses: ./.github/workflows/ci.yml
    secrets: inherit

  build:
    name: Build ${{ matrix.platform }}
    needs: ci
    runs-on: ${{ matrix.os }}
    environment: default
    strategy:
      matrix:
        include:
          - platform: linux
            preset: Linux
            artifact: daccord-linux-x86_64
            extension: x86_64
            os: ubuntu-latest
          - platform: linux-arm64
            preset: "Linux ARM64"
            artifact: daccord-linux-arm64
            extension: arm64
            os: ubuntu-latest
          - platform: windows
            preset: Windows
            artifact: daccord-windows-x86_64
            extension: exe
            os: ubuntu-latest
          - platform: macos
            preset: macOS
            artifact: daccord-macos
            extension: zip
            os: macos-latest

    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true

      - name: Validate version matches tag
        run: |
          TAG="${GITHUB_REF#refs/tags/v}"
          PROJECT_VER=$(grep 'config/version=' project.godot | sed 's/.*="//' | sed 's/"//')
          if [ "$TAG" != "$PROJECT_VER" ]; then
            echo "::error::Tag v$TAG does not match project.godot version $PROJECT_VER"
            exit 1
          fi

      - name: Install audio libraries (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq libasound2-dev libpulse-dev libopus-dev

      - name: Cache GUT
        uses: actions/cache@v4
        with:
          path: addons/gut
          key: gut-${{ env.GUT_VERSION }}

      - name: Install GUT
        run: |
          if [ ! -d addons/gut ]; then
            curl -sL https://github.com/bitwes/Gut/archive/refs/tags/v${GUT_VERSION}.tar.gz -o /tmp/gut.tar.gz
            tar xzf /tmp/gut.tar.gz -C /tmp
            cp -r /tmp/Gut-${GUT_VERSION}/addons/gut addons/gut
            rm -rf /tmp/gut.tar.gz /tmp/Gut-${GUT_VERSION}
          fi

      - name: Cache Sentry SDK
        uses: actions/cache@v4
        with:
          path: addons/sentry
          key: sentry-godot-${{ env.SENTRY_VERSION }}

      - name: Install Sentry SDK
        run: |
          if [ ! -d addons/sentry ]; then
            gh release download $SENTRY_VERSION --repo getsentry/sentry-godot \
              --pattern "*.zip" --dir /tmp/sentry_dl
            unzip -o /tmp/sentry_dl/*.zip -d /tmp/sentry_extract
            cp -r /tmp/sentry_extract/addons/sentry addons/sentry
            rm -rf /tmp/sentry_dl /tmp/sentry_extract
          fi
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Install godot-livekit addon (latest release)
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Downloading godot-livekit addon (latest release)..."
          TMPDIR=$(mktemp -d)
          gh release download --repo NodotProject/godot-livekit \
            --pattern "godot-livekit-release.zip" --dir "$TMPDIR"
          unzip -o "$TMPDIR/godot-livekit-release.zip" -d "$TMPDIR/extracted"
          if [ ! -d "$TMPDIR/extracted/addons/godot-livekit" ]; then
            echo "::error::godot-livekit addon not found in release asset"
            exit 1
          fi
          rm -rf addons/godot-livekit
          cp -R "$TMPDIR/extracted/addons/godot-livekit" addons/godot-livekit
          rm -rf "$TMPDIR"
          echo "godot-livekit addon installed from latest release."

      - name: Remove godot-livekit if platform binary missing
        run: |
          # Godot crashes on macOS (NSException) if a GDExtension references
          # a missing dylib. Safest fix: remove the extension entirely.
          GDEXT="addons/godot-livekit/godot-livekit.gdextension"
          if [ ! -f "$GDEXT" ]; then
            echo "No godot-livekit GDExtension found, skipping."
            exit 0
          fi
          case "${{ matrix.platform }}" in
            linux)       LIB="addons/godot-livekit/bin/libgodot-livekit.linux.x86_64.so" ;;
            linux-arm64) LIB="addons/godot-livekit/bin/libgodot-livekit.linux.x86_64.so" ;;
            windows)     LIB="addons/godot-livekit/bin/libgodot-livekit.windows.x86_64.dll" ;;
            macos)       LIB="addons/godot-livekit/bin/libgodot-livekit.macos.universal.dylib" ;;
          esac
          if [ ! -f "$LIB" ]; then
            echo "::warning::godot-livekit binary $LIB not found — removing GDExtension to prevent crash"
            rm -f "$GDEXT" "$GDEXT.uid"
          else
            echo "godot-livekit binary found: $LIB"
          fi

      - name: Set up Godot
        uses: chickensoft-games/setup-godot@v2
        with:
          version: ${{ env.GODOT_VERSION }}
          use-dotnet: false
          include-templates: true

      - name: Cache Godot import
        uses: actions/cache@v4
        with:
          path: .godot/imported
          key: godot-import-${{ env.GODOT_VERSION }}-${{ matrix.platform }}-${{ hashFiles('project.godot', '**/*.tscn', '**/*.tres') }}
          restore-keys: |
            godot-import-${{ env.GODOT_VERSION }}-${{ matrix.platform }}-

      - name: Import project
        run: godot --headless --import . || true
        timeout-minutes: 2

      - name: Inject Sentry DSN
        if: env.SENTRY_DSN != ''
        env:
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
        run: |
          sed -i.bak 's|config/dsn="[^"]*"|config/dsn="'"$SENTRY_DSN"'"|' project.godot
          rm -f project.godot.bak

      - name: Download GodotLite template
        if: matrix.platform != 'linux-arm64'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p dist/templates
          case "${{ matrix.platform }}" in
            linux)
              ASSET="godotlite-${GODOTLITE_TAG}-linux-x86_64"
              DEST="dist/templates/godot.linuxbsd.template_release.x86_64"
              ;;
            windows)
              ASSET="godotlite-${GODOTLITE_TAG}-windows-x86_64.exe"
              DEST="dist/templates/godot.windows.template_release.x86_64.exe"
              ;;
            macos)
              ASSET="godotlite-${GODOTLITE_TAG}-macos-universal"
              DEST="dist/templates/godot.macos.template_release.universal"
              ;;
          esac
          gh release download "${GODOTLITE_TAG}" \
            --repo NodotProject/GodotLite \
            --pattern "${ASSET}" \
            --dir dist/templates
          mv "dist/templates/${ASSET}" "${DEST}"
          chmod +x "${DEST}"
          echo "GodotLite template installed: ${DEST} ($(du -h "${DEST}" | cut -f1))"

      - name: Clear missing custom templates
        run: |
          # If a custom template path is set but the file doesn't exist,
          # clear it so Godot falls back to stock templates.
          while IFS= read -r line; do
            if [[ "$line" =~ custom_template/release=\"res://(.+)\" ]]; then
              TEMPLATE_PATH="${BASH_REMATCH[1]}"
              if [ -n "$TEMPLATE_PATH" ] && [ ! -f "$TEMPLATE_PATH" ]; then
                echo "Custom template not found: $TEMPLATE_PATH — clearing for stock fallback"
                sed -i.bak "s|custom_template/release=\"res://$TEMPLATE_PATH\"|custom_template/release=\"\"|" export_presets.cfg
              fi
            fi
          done < export_presets.cfg
          rm -f export_presets.cfg.bak

      - name: Create build directory
        run: mkdir -p dist/build/${{ matrix.platform }}

      - name: Export ${{ matrix.preset }}
        run: godot --headless --export-release "${{ matrix.preset }}"
        timeout-minutes: 10

      - name: Package Linux
        if: startsWith(matrix.platform, 'linux')
        run: |
          cd dist/build/${{ matrix.platform }}
          # Include .desktop file and icon for Linux packages
          cp ../../../dist/daccord.desktop . 2>/dev/null || true
          cp ../../../assets/icons/icon_128x128.png daccord.png 2>/dev/null || true
          tar czf ../../../${{ matrix.artifact }}.tar.gz *

      - name: Package Windows
        if: matrix.platform == 'windows'
        run: |
          cd dist/build/windows
          zip -r ../../../${{ matrix.artifact }}.zip *

      - name: Sign Windows executable
        if: matrix.platform == 'windows' && env.WINDOWS_CERT_BASE64 != ''
        env:
          WINDOWS_CERT_BASE64: ${{ secrets.WINDOWS_CERT_BASE64 }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
        run: |
          sudo apt-get install -y osslsigncode
          echo "$WINDOWS_CERT_BASE64" | base64 -d > cert.pfx
          # Re-extract, sign, re-package
          mkdir -p signed_windows
          cd signed_windows
          unzip ../daccord-windows-x86_64.zip
          osslsigncode sign \
            -pkcs12 ../cert.pfx \
            -pass "$WINDOWS_CERT_PASSWORD" \
            -n "daccord" \
            -t http://timestamp.digicert.com \
            -in daccord.exe \
            -out daccord_signed.exe
          mv daccord_signed.exe daccord.exe
          zip -r ../daccord-windows-x86_64.zip *
          cd ..
          rm -f cert.pfx
          rm -rf signed_windows

      - name: Package macOS
        if: matrix.platform == 'macos'
        run: |
          cp dist/build/macos/daccord.zip ${{ matrix.artifact }}.zip

      - name: Sign macOS app bundle
        if: matrix.platform == 'macos' && env.APPLE_CERTIFICATE_BASE64 != ''
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
        run: |
          # Import certificate into a temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "$APPLE_CERTIFICATE_BASE64" | base64 -d > $RUNNER_TEMP/cert.p12
          security import $RUNNER_TEMP/cert.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain-db
          security set-key-partition-list -S apple-tool:,apple: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Unzip, sign, re-zip
          mkdir -p $RUNNER_TEMP/macos_app
          unzip -o ${{ matrix.artifact }}.zip -d $RUNNER_TEMP/macos_app
          codesign --deep --force --options runtime \
            --sign "$APPLE_IDENTITY" \
            $RUNNER_TEMP/macos_app/daccord.app
          cd $RUNNER_TEMP/macos_app
          zip -r $GITHUB_WORKSPACE/${{ matrix.artifact }}.zip daccord.app
          cd $GITHUB_WORKSPACE

          # Cleanup
          rm -f $RUNNER_TEMP/cert.p12
          security delete-keychain "$KEYCHAIN_PATH"

      - name: Notarize macOS app
        if: matrix.platform == 'macos' && env.APPLE_ID != ''
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          xcrun notarytool submit ${{ matrix.artifact }}.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket
          mkdir -p $RUNNER_TEMP/macos_staple
          unzip -o ${{ matrix.artifact }}.zip -d $RUNNER_TEMP/macos_staple
          xcrun stapler staple $RUNNER_TEMP/macos_staple/daccord.app
          cd $RUNNER_TEMP/macos_staple
          zip -r $GITHUB_WORKSPACE/${{ matrix.artifact }}.zip daccord.app
          cd $GITHUB_WORKSPACE
          rm -rf $RUNNER_TEMP/macos_staple

      - name: Create macOS DMG
        if: matrix.platform == 'macos'
        run: |
          TMPDIR="$RUNNER_TEMP/dmg_build"
          rm -rf "$TMPDIR"
          mkdir -p "$TMPDIR"
          unzip -o ${{ matrix.artifact }}.zip -d "$TMPDIR"
          ln -s /Applications "$TMPDIR/Applications"
          hdiutil create \
            -volname "daccord" \
            -srcfolder "$TMPDIR" \
            -ov -format UDZO \
            "$GITHUB_WORKSPACE/${{ matrix.artifact }}.dmg"
          rm -rf "$TMPDIR"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: ${{ matrix.artifact }}.*

  windows-installer:
    name: Build Windows installer
    needs: build
    runs-on: windows-latest
    environment: default
    steps:
      - uses: actions/checkout@v4

      - name: Download Windows build artifact
        uses: actions/download-artifact@v4
        with:
          name: daccord-windows-x86_64
          path: .

      - name: Extract Windows build
        run: |
          mkdir -p dist/build/windows
          Expand-Archive -Path daccord-windows-x86_64.zip -DestinationPath dist/build/windows
        shell: pwsh

      - name: Get version from project.godot
        id: version
        run: |
          $ver = (Select-String -Path project.godot -Pattern 'config/version="([^"]+)"').Matches.Groups[1].Value
          echo "APP_VERSION=$ver" >> $env:GITHUB_OUTPUT
        shell: pwsh

      - name: Compile installer with Inno Setup
        run: |
          iscc "/DMyAppVersion=${{ steps.version.outputs.APP_VERSION }}" dist\installer.iss
        shell: cmd

      - name: Sign installer
        if: env.WINDOWS_CERT_BASE64 != ''
        env:
          WINDOWS_CERT_BASE64: ${{ secrets.WINDOWS_CERT_BASE64 }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
        run: |
          $certBytes = [Convert]::FromBase64String($env:WINDOWS_CERT_BASE64)
          [IO.File]::WriteAllBytes("cert.pfx", $certBytes)
          & signtool sign /f cert.pfx /p $env:WINDOWS_CERT_PASSWORD /t http://timestamp.digicert.com /d "daccord" dist\daccord-windows-x86_64-setup.exe
          Remove-Item cert.pfx
        shell: pwsh

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: daccord-windows-x86_64-setup
          path: dist/daccord-windows-x86_64-setup.exe

  release:
    name: Create Release
    needs: [build, windows-installer]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          merge-multiple: true

      - name: Extract changelog for this version
        id: changelog
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION="${TAG#v}"
          # Extract the section for this version from CHANGELOG.md
          NOTES=$(awk "/^## \[${VERSION}\]/{found=1; next} /^## \[/{found=0} found" CHANGELOG.md)
          if [ -z "$NOTES" ]; then
            NOTES="Release ${TAG}"
          fi
          echo "notes<<EOF" >> "$GITHUB_OUTPUT"
          echo "$NOTES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          name: ${{ github.ref_name }}
          body: ${{ steps.changelog.outputs.notes }}
          draft: false
          prerelease: ${{ contains(github.ref_name, '-') }}
          files: artifacts/*
